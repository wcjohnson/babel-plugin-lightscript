import patch from './util/babelTypesPatch'
import { registerLightscriptNodeTypes } from './lscNodeTypes'

import { resetHelpers } from "./state/helpers"; // XXX: should be part of state init
import { getParserOpts, parseConfigurationDirectives } from './config'
import findBabelOptionsForPlugin from './util/findBabelOptionsForPlugin'
import { getFileTypeInfo, createCompilerState, initializeCompilerState, postprocess } from './state/compilerState'

import visitAstFixup from './visitors/fixAst'
import visitPlaceholders from './visitors/placeholders'
import visitOptionalChains from './visitors/optionalChains'
import visitMain from './visitors/main'

// TODO: factor out to config.lsc
computeParserOpts(file, pluginOpts) ->
  // By this time, we have access to the code of the file.
  // We can parse shebang, directives, etc and manipulate parser options
  // based on those data.
  file.parseShebang()
  { opts, parserOpts } = file
  fileTypeInfo = getFileTypeInfo(file)
  cdOpts = parseConfigurationDirectives(file.code)

  // Don't read as LSC
  if (not fileTypeInfo.isLightScript) and (not cdOpts.isLightScript): return

  file.isLightScript = true
  Object.assign(pluginOpts, cdOpts)

  // Get LSC parser opts
  opts.parserOpts = opts.parserOpts or {}
  nextParserOpts = getParserOpts(pluginOpts, opts.parserOpts)
  parserOpts.parse = nextParserOpts.parse
  parserOpts.plugins = nextParserOpts.plugins

export default LightScript(babel) ->
  { types: t } = babel
  patch(t)
  registerLightscriptNodeTypes(t)

  plugin = {
    manipulateOptions(opts, parserOpts, file) ->
      // manipulateOptions is called very early in the Babel processing chain.
      // It doesn't get an opportunity to see the configuration options for the
      // plugin being run (without a workaround) nor does it get an
      // opportunity to see the code that will be compiled.
      //
      // This rules out things like parsing configuration directives from the
      // top of a JS file to manipulate parsing and compiling options.
      //
      // To remedy this, we monkey patch so that we can do initialization work
      // after the code is read, but before the parser runs.
      //
      // Relevant Babel code:
      // https://github.com/babel/babel/blob/4e50b2d9d9c376cee7a2cbf56553fe5b982ea53c/packages/babel-core/src/transformation/file/index.js#L63
      // https://github.com/babel/babel/blob/4e50b2d9d9c376cee7a2cbf56553fe5b982ea53c/packages/babel-core/src/transformation/file/index.js#L483
      origAddCode = file.addCode

      file.addCode(code) ->
        origAddCode.call(this, code)
        pluginOpts = findBabelOptionsForPlugin(this.opts, plugin)

        // compiler = createCompilerState()
        // this.lscCompiler = compiler
        // compiler~preParseInitialization(this, code, this.opts, pluginOpts)
        computeParserOpts(this, pluginOpts)
        return

    visitor: {
      // The compiler's main loop is a Program visitor.
      Program(path, state): void ->
        ////////// Initialize compilation run
        // Obtain configuration
        opts = state.opts
        compiler = createCompilerState({
          programPath: path
          babel
          opts
          file: state.file
        })

        // Early-out if not a LightScript program
        if (!compiler.isLightScript) return

        initializeCompilerState()

        // TODO: helpers -> compilerState
        resetHelpers(path)

        ////////// AST visitation and transformation
        // First pass: Perform basic ast fixups (block bodies, etc)
        compiler~visitAstFixup(path)
        // Second pass: transform placeholders
        if compiler.opts.placeholderArgs:
          compiler~visitPlaceholders(path)
        // Third pass: transform optional chains
        compiler~visitOptionalChains(path)
        // Main ast visitor
        compiler~visitMain(path)

        ////////// Post-processing
        // Fix up loose ends like adding `import` statements
        compiler~postprocess()
    }
  }
