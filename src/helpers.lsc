import { getBabel } from './babelInstance'
import { isa } from './is'

let helpers = {}
let helperPath = null

export resetHelpers(path) ->
  now helperPath = path
  now helpers = {}

insertAfterImports(path, node): void ->
  for elem p in path.get("body"):
    if not p~isa("ImportDeclaration"):
      p.insertBefore(node)
      break

export getHelper(key, makeHelper) ->
  helper = helpers[key]
  if helper: return helper

  let functionExpr = makeHelper()
  // babel-template fixup
  if functionExpr.type === "ExpressionStatement": now functionExpr = functionExpr.expression

  // c/p https://github.com/babel/babel/blob/7.0/packages/babel-core/src/transformation/file/index.js#L206
  ref = helperPath.scope.generateUidIdentifier(key)

  functionExpr.body._compact = true
  functionExpr._generated = true
  functionExpr.id = ref
  functionExpr.type = "FunctionDeclaration"

  insertAfterImports(helperPath, functionExpr)

  helpers[key] = ref

predefinedHelpers = {
  isObject(b) ->
    b.template(`
(function(obj) {
  return obj != null && (typeof obj === "object" || typeof obj === "function")
})
    `)()

  hasLength(b) ->
    b.template(`
(function(arr, minLength, maxLength) {
  return(
    arr != null &&
    typeof arr !== "function" &&
    (maxLength === undefined ?
      (minLength ? arr.length >= minLength : arr.length >= 0) :
      (arr.length >= minLength && arr.length <= maxLength)
    )
  )
})
    `)()

}

export helper(name) ->
  makeHelper = predefinedHelpers[name]
  if not makeHelper: throw new Error(`no such helper ${name}`)
  getHelper(name, -> makeHelper(getBabel()))
