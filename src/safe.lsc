import t from './types'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import { hoistRef } from './ref'
import is, { isa } from './is'
import { ensureBlockArrowFunctionExpression } from './functions'

import { getLoc, placeTreeAtLocWhenUnplaced as allAtLoc } from 'ast-loc-utils'

export transformExistentialExpression(path) ->
  path.replaceWith(
    t.binaryExpression(
      "!=",
      path.node.argument,
      t.nullLiteral()~atNode(path.node)
    )~atNode(path.node)
  )

export replaceWithSafeCall(path, callExpr) ->
  undef = path.scope.buildUndefinedNode()
  let callee, typeofExpr

  if is("MemberExpression", callExpr.callee):
    memberExpr = callExpr.callee
    { ref: objectRef, assign: object } = hoistRef(path, memberExpr.object, "obj")

    let property = memberExpr.property, propertyRef = memberExpr.property
    if memberExpr.computed:
      now { ref: propertyRef, assign: property } = hoistRef(path, memberExpr.property, "prop")

    now typeofExpr = t.memberExpression(object, property, memberExpr.computed)
    now callee = t.memberExpression(objectRef, propertyRef, memberExpr.computed)
  else:
    now { ref: callee, assign: typeofExpr } = hoistRef(path, callExpr.callee)

  // Generate actual safecall expr
  // f?(x) -> (typeof f === "function") ? f(x) : undefined
  path.replaceWith(
    t.conditionalExpression(
      t.binaryExpression("===",
        t.unaryExpression("typeof", typeofExpr),
        t.stringLiteral("function")
      ),
      t.callExpression(callee, callExpr.arguments),
      undef
    )~allAtLoc(getLoc(path.node))
  )

export transformSafeMemberExpression(path) ->
  // x?.y -> x == null ? x : x.y
  // x?[y] -> x == null ? x : x[y]
  { node } = path
  { object } = node

  // Transform to vanilla member expr
  node.optional = false

  // Generate null check, hoisting ref if necessary.
  left = if object.type === "Identifier" or (object.type === "MemberExpression" and object.optional):
    object
  else:
    // "Lazy man's" fix for the `?.` fat arrow bug.
    // The ref hoist below would cause a bodiless ArrowExpression to gain a body with a declared ref at the top.
    // This invalidates the `path`, which now points to a bodiless arrow function that no longer exists in the ast.
    // Instead let's handle that case early.
    if path.parent~isa("ArrowFunctionExpression"):
      path.parentPath~ensureBlockArrowFunctionExpression()
      now path = path.parentPath.get("body.body.0.expression")

    ref = path.scope.generateDeclaredUidIdentifier("ref")~atNode(object)
    node.object = ref
    t.assignmentExpression("=", ref, object)~atNode(object)

  nullCheck = t.binaryExpression("==", left, t.nullLiteral()~atNode(object))~atNode(object)

  // Gather trailing subscripts/calls, which are parent nodes:
  // eg; in `o?.x.y()`, group trailing `.x.y()` into the ternary
  let tail = path
  while tail.parentPath:
    parent = tail.parentPath;
    hasChainedParent = (
      parent.isMemberExpression() ||
      (parent.isCallExpression() && parent.get("callee") === tail) ||
      (parent.node.type === "TildeCallExpression" && parent.get("left") === tail)
    )

    if hasChainedParent:
      now tail = tail.parentPath
    else:
      break

  undef = tail.scope.buildUndefinedNode()

  ternary = t.conditionalExpression(
    nullCheck
    undef~atNode(tail.node)
    tail.node
  )~atNode(tail.node)

  tail.replaceWith(ternary);
