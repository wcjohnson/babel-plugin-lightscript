import t from './types'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import { hoistRef, isSimple } from './ref'
import is, { isa } from './is'
import { ensureBlockArrowFunctionExpression } from './functions'

import { getLoc, placeTreeAtLocWhenUnplaced as allAtLoc } from 'ast-loc-utils'

// Optional-replacement algorithm based on babel-plugin-transform-optional-chaining
// See https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-optional-chaining/src/index.js

findReplacementPath(path) ->
  path.find(path ->
    { key, parentPath } = path
    if key == "left" and parentPath~isa("AssignmentExpression"): false
    elif key == "object" and parentPath~isa("MemberExpression"): false
    elif key == "callee" and (parentPath~isa("CallExpression") or parentPath~isa("NewExpression")): false
    elif key == "argument" and parentPath~isa("UpdateExpression"): false
    elif key == "argument" and (parentPath~isa("UnaryExpression") and parentPath.node.operator == "delete"): false
    else: true
  )

replaceOptionals(path, replacementPath, loose = true): void ->
  { scope } = path
  optionals = []
  nil = scope.buildUndefinedNode()

  // Collect all optional nodes within the local cluster of nodes
  let objectPath = path
  while objectPath~isa("MemberExpression") or objectPath~isa("CallExpression") or objectPath~isa("NewExpression"):
    { node } = objectPath;
    if node.optional: optionals.push(node)

    if objectPath~isa("MemberExpression"):
      now objectPath = objectPath.get("object")
    else:
      now objectPath = objectPath.get("callee")

  // Traverse optionals from innermost to outermost
  for let i = optionals.length - 1; i >= 0; i--:
    node = optionals[i]
    node.optional = false

    isCall = node~isa("CallExpression");
    replaceKey = if isCall or node~isa("NewExpression"): "callee" else: "object"
    chain = node[replaceKey]

    let ref, check
    if loose and isCall:
      // If we are using a loose transform (avoiding a Function#call) and we are at the call,
      // we can avoid a needless memoize.
      now check = now ref = chain
    else:
      if not chain~isSimple():
        now ref = scope.maybeGenerateMemoised(chain)
      if ref:
        now check = t.assignmentExpression("=", ref, chain)
        node[replaceKey] = ref;
      else:
        now check = now ref = chain;

    // Ensure call expressions have the proper `this`
    // `foo.bar()` has context `foo`.
    if isCall && chain~isa("MemberExpression"):
      if loose:
        // To avoid a Function#call, we can instead re-grab the property from the context object.
        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`
        node.callee = chain
      else:
        // Otherwise, we need to memoize the context object, and change the call into a Function#call.
        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`
        { object } = chain
        let context = scope.maybeGenerateMemoised(object);
        if (context) {
          chain.object = t.assignmentExpression("=", context, object);
        } else {
          now context = object
        }

        node.arguments.unshift(context)
        node.callee = t.memberExpression(node.callee, t.identifier("call"))

    replacementPath.replaceWith(
      t.conditionalExpression(
        t.binaryExpression("==", check, t.nullLiteral()),
        nil,
        replacementPath.node,
      ),
    )

    now replacementPath = replacementPath.get("alternate")

export maybeTransformSafe(path): void ->
  if path.node.optional:
    replaceOptionals(path, path~findReplacementPath(), true)

export transformExistentialExpression(path) ->
  path.replaceWith(
    t.binaryExpression(
      "!=",
      path.node.argument,
      t.nullLiteral()~atNode(path.node)
    )~atNode(path.node)
  )

export replaceWithSafeCall(path, callExpr) ->
  undef = path.scope.buildUndefinedNode()
  let callee, typeofExpr

  if is("MemberExpression", callExpr.callee):
    memberExpr = callExpr.callee
    { ref: objectRef, assign: object } = hoistRef(path, memberExpr.object, "obj")

    let property = memberExpr.property, propertyRef = memberExpr.property
    if memberExpr.computed:
      now { ref: propertyRef, assign: property } = hoistRef(path, memberExpr.property, "prop")

    now typeofExpr = t.memberExpression(object, property, memberExpr.computed)
    now callee = t.memberExpression(objectRef, propertyRef, memberExpr.computed)
  else:
    now { ref: callee, assign: typeofExpr } = hoistRef(path, callExpr.callee)

  // Generate actual safecall expr
  // f?(x) -> (typeof f === "function") ? f(x) : undefined
  path.replaceWith(
    t.conditionalExpression(
      t.binaryExpression("===",
        t.unaryExpression("typeof", typeofExpr),
        t.stringLiteral("function")
      ),
      t.callExpression(callee, callExpr.arguments),
      undef
    )~allAtLoc(getLoc(path.node))
  )

export transformSafeMemberExpression(path) ->
  // x?.y -> x == null ? x : x.y
  // x?[y] -> x == null ? x : x[y]
  { node } = path
  { object } = node

  // Transform to vanilla member expr
  node.optional = false

  // Generate null check, hoisting ref if necessary.
  left = if object.type === "Identifier" or (object.type === "MemberExpression" and object.optional):
    object
  else:
    ref = path.scope.generateDeclaredUidIdentifier("ref")~atNode(object)
    node.object = ref
    t.assignmentExpression("=", ref, object)~atNode(object)

  nullCheck = t.binaryExpression("==", left, t.nullLiteral()~atNode(object))~atNode(object)

  // Gather trailing subscripts/calls, which are parent nodes:
  // eg; in `o?.x.y()`, group trailing `.x.y()` into the ternary
  let tail = path
  while tail.parentPath:
    parent = tail.parentPath;
    hasChainedParent = (
      parent.isMemberExpression() ||
      (parent.isCallExpression() && parent.get("callee") === tail) ||
      (parent.node.type === "TildeCallExpression" && parent.get("left") === tail)
    )

    if hasChainedParent:
      now tail = tail.parentPath
    else:
      break

  undef = tail.scope.buildUndefinedNode()

  ternary = t.conditionalExpression(
    nullCheck
    undef~atNode(tail.node)
    tail.node
  )~atNode(tail.node)

  tail.replaceWith(ternary);
