import t from './types'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import { hoistRef } from './ref'
import is from './is'

import { getLoc, placeTreeAtLocWhenUnplaced as allAtLoc } from 'ast-loc-utils'

export transformExistentialExpression(path) ->
  path.replaceWith(
    t.binaryExpression(
      "!=",
      path.node.argument,
      t.nullLiteral()~atNode(path.node)
    )~atNode(path.node)
  )

export replaceWithSafeCall(path, callExpr) ->
  let callee, typeofExpr

  if is("MemberExpression", callExpr.callee):
    memberExpr = callExpr.callee
    { ref: objectRef, assign: object } = hoistRef(path, memberExpr.object, "obj")

    let property = memberExpr.property, propertyRef = memberExpr.property
    if memberExpr.computed:
      now { ref: propertyRef, assign: property } = hoistRef(path, memberExpr.property, "prop")

    now typeofExpr = t.memberExpression(object, property, memberExpr.computed)
    now callee = t.memberExpression(objectRef, propertyRef, memberExpr.computed)
  else:
    now { ref: callee, assign: typeofExpr } = hoistRef(path, callExpr.callee)

  // Generate actual safecall expr
  // f?(x) -> (typeof f === "function") ? f(x) : null
  path.replaceWith(
    t.conditionalExpression(
      t.binaryExpression("===",
        t.unaryExpression("typeof", typeofExpr),
        t.stringLiteral("function")
      ),
      t.callExpression(callee, callExpr.arguments),
      t.nullLiteral()
    )~allAtLoc(getLoc(path.node))
  )

export transformSafeMemberExpression(path) ->
  // x?.y -> x == null ? x : x.y
  // x?[y] -> x == null ? x : x[y]
  { node } = path
  { object } = node

  // Demote to an ordinary member expression
  node.type = "MemberExpression"

  // Generate null check, hoisting ref if necessary.
  left = if object.type === "Identifier" or object.type === "SafeMemberExpression" or object.type === "ThisExpression":
    object
  else:
    ref = path.scope.generateDeclaredUidIdentifier("ref")~atNode(object)
    node.object = ref
    t.assignmentExpression("=", ref, object)~atNode(object)

  nullCheck = t.binaryExpression("==", left, t.nullLiteral()~atNode(object))~atNode(object)

  // Gather trailing subscripts/calls, which are parent nodes:
  // eg; in `o?.x.y()`, group trailing `.x.y()` into the ternary
  let tail = path
  while tail.parentPath:
    parent = tail.parentPath;
    hasChainedParent = (
      parent.isMemberExpression() ||
      (parent.isCallExpression() && parent.get("callee") === tail) ||
      (parent.node.type === "TildeCallExpression" && parent.get("left") === tail)
    )

    if hasChainedParent:
      now tail = tail.parentPath
    else:
      break

  ternary = t.conditionalExpression(
    nullCheck
    t.nullLiteral()~atNode(tail.node)
    tail.node
  )~atNode(tail.node)

  tail.replaceWith(ternary);
