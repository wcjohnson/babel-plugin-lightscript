// Convert a series of statements to an expression.
// Largely c/p from babel-types and babel-traverse.
// Modified to add source mapping information to produced nodes.
import t from '../types'
import { iife } from '../blocks'
import { isa } from '../is'

import { getSurroundingLoc, placeAtLoc as atLoc, placeAtNode as atNode } from 'ast-loc-utils'

// c/p https://github.com/babel/babel/blob/master/packages/babel-types/src/converters.js

gatherSequenceExpressions(nodes: Array<Object>): ?Object ->
  exprs = []
  let ensureLastNull = true

  for elem node in nodes:
    now ensureLastNull = false

    match node:
      | ~isa("Expression"):
        exprs.push(node)
      | ~isa("ExpressionStatement"):
        exprs.push(node.expression)
      | ~isa("IfStatement") as { consequent, alternate, test }:
        cq = consequent // XXX: https://github.com/lightscript/lightscript/issues/39
        alt = alternate // XXX: https://github.com/lightscript/lightscript/issues/39
        if (!cq) return
        nextCq = gatherSequenceExpressions([cq])
        nextAlt = alt ? gatherSequenceExpressions([alt]) : t.unaryExpression("void", t.numericLiteral(0)~atNode(cq), true)~atNode(cq)
        if (!nextCq || !nextAlt) return

        loc = getSurroundingLoc([test, nextCq, nextAlt])
        exprs.push(t.conditionalExpression(test, nextCq, nextAlt)~atLoc(loc))
      | ~isa("BlockStatement"):
        body = gatherSequenceExpressions(node.body)
        if (!body) return
        exprs.push(body)
      | ~isa("EmptyStatement"):
        now ensureLastNull = true
      | else:
        return

  if ensureLastNull:
    exprs.push(t.nullLiteral()~atNode(exprs[exprs.length - 1]))

  if exprs.length == 1: exprs[0] else: t.sequenceExpression(exprs)

toSequenceExpression(nodes: Array<Object>): ?Object ->
  if (!nodes || !nodes.length) return
  gatherSequenceExpressions(nodes)

// c/p https://github.com/babel/babel/blob/1e55653ac173c3a59f403a7b5269cf6d143d32d9/packages/babel-traverse/src/path/replacement.js

export default statementsToExpression(path, nodes: Array<Object>) ->
  path.resync()

  seqExpr = toSequenceExpression(nodes);

  if t.isSequenceExpression(seqExpr):
    exprs = seqExpr.expressions

    if exprs.length >= 2 && path.parentPath.isExpressionStatement():
      path._maybePopFromStatements(exprs)

    // could be just one element due to the previous maybe popping
    if exprs.length === 1: exprs[0] else: seqExpr
  elif seqExpr:
    seqExpr
  else:
    iife(nodes)
