import * as babylonLightScript from "@oigroup/babylon-lightscript";
import packageMetadata from "../package.json";
import parseConfigurationDirectives from './util/parseConfigurationDirectives'

export getMetadata() ->
  {
    parser: babylonLightScript
    getParserOpts
    parseConfigurationDirectives
    name: packageMetadata.name
    version: packageMetadata.version
    options: {
      stdlib: {
        description: "Configure the LightScript standard library"
      }
      patternMatching: {
        description: "Test and branch using `match` keyword"
        valueType: "option"
        options: ["default", "enhanced"]
        defaultValue: "default"
        stage: "1"
      }
      whiteblock: {
        description: "Disable `{` `}` as block delimiters."
        valueType: "boolean"
      }
      bangCall: {
        description: "Call functions with paren-free syntax using `!`"
        valueType: "boolean"
        defaultValue: true
      }
      safeCall: {
        description: "Call a function using `?` to check callability first"
        valueType: "boolean"
        defaultValue: true
      }
      existential: {
        description: "Postfix `?` checks that an expression is not loose-equal to `null`"
        valueType: "boolean"
      }
      enhancedComprehension: {
        description: "Positional comprehensions and `case` syntax for comprehensions"
        valueType: "boolean"
        stage: "0"
      }
      noEnforcedSubscriptIndentation: {
        description: "Do not enforce indentation for subscripts on subsequent lines."
        valueType: "boolean"
      }
      useRequire: {
        description: "Generate `require` rather than `import` when the compiler introduces a module."
        valueType: "boolean"
      }
      flippedImports: {
        description: "Allow imports via `import 'path': [specifier]` syntax."
        valueType: "boolean"
      }
      disableJsx: {
        description: "Don't parse JSX expressions."
        valueType: "boolean"
      }
      disableFlow: {
        description: "Don't parse Flow type annotations."
        valueType: "boolean"
      }
      placeholderArgs: {
        description: "Specify arguments for a function using placeholders in the body."
        valueType: "boolean"
      }
      placeholder: {
        description: "Specify an identifier to be transformed into PlaceholderExpression."
        valueType: "string"
      }
      pipeCall: {
        description: "a |> b infix binary operator invokes b(a)"
        valueType: "boolean"
      }
    }
  }

export getParserOpts(pluginOpts, initialParserOpts) ->
  parserOpts = initialParserOpts or {}
  parserOpts.parser = babylonLightScript.parse

  parserOpts.plugins = parserOpts.plugins or []
  plugins = parserOpts.plugins

  plugins.unshift("lightscript")
  plugins.push(
    "objectRestSpread", "asyncFunctions", "asyncGenerators"
    "classProperties", "classConstructorCall", "decorators"
    "dynamicImport", "doExpressions", "seqExprRequiresParen"
    "noLabeledExpressionStatements"
  )

  if pluginOpts?.whiteblock:
    if pluginOpts.whiteblock != "compat":
      plugins.push("whiteblockOnly")
  else:
    plugins.push("whiteblockPreferred")

  if not pluginOpts?.disableJsx: plugins.push("jsx")
  if not pluginOpts?.disableFlow: plugins.push("flow")
  if pluginOpts?.safeCall != false: plugins.push("safeCallExpression")
  if pluginOpts?.existential: plugins.push("existentialExpression")
  if pluginOpts?.bangCall != false: plugins.push("bangCall")
  if not pluginOpts?.noEnforcedSubscriptIndentation: plugins.push("enforceSubscriptIndentation")
  if pluginOpts?.flippedImports: plugins.push("flippedImports")
  if pluginOpts?.enhancedComprehension != false: plugins.push("splatComprehension")
  if pluginOpts?.placeholderArgs: plugins.push("syntacticPlaceholder")
  if pluginOpts?.placeholder:
    parserOpts.placeholder = pluginOpts.placeholder
  if pluginOpts?.pipeCall: plugins.push("pipeCall")

  // TODO: watch upstream on pattern matching; default to their syntax when complete
  // patternMatchingVersion = pluginOpts?.patternMatching or "v4"
  // if patternMatchingVersion != "disabled":
  //   plugins.push(`match_${patternMatchingVersion}`)
  plugins.push("match")

  parserOpts

export preParseInitialization(compiler, babelFile, pluginOpts) ->
  babelFile.parseShebang()
  { opts, parserOpts, code } = babelFile
  directiveOpts = parseConfigurationDirectives(code)



// XXX: shouldn't be needed, refactor
export { parseConfigurationDirectives }
