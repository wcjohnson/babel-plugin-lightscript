import * as parser from "@oigroup/babylon-lightscript";
import packageMetadata from "../package.json";

export getMetadata() ->
  {
    parser
    getParserOpts
    name: packageMetadata.name
    version: packageMetadata.version
    options: {
      stdlib: {
        description: "Configure the LightScript standard library"
      }
      patternMatching: {
        description: "Test and branch using `match` keyword"
        valueType: "option"
        options: ["disabled", "v3", "v4"]
        defaultValue: "v4"
        stage: "1"
      }
      bangCall: {
        description: "Call functions with paren-free syntax using `!`"
        valueType: "boolean"
        stage: "0"
      }
      safeCall: {
        description: "Call a function using `?` to check callability first"
        valueType: "boolean"
      }
      existential: {
        description: "Postfix `?` checks that an expression is not loose-equal to `null`"
        valueType: "boolean"
      }
      enhancedComprehension: {
        description: "Positional comprehensions and `case` syntax for comprehensions"
        valueType: "boolean"
      }
      noEnforcedSubscriptIndentation: {
        description: "Do not enforce indentation for subscripts on subsequent lines."
        valueType: "boolean"
      }
      useRequire: {
        description: "Generate `require` rather than `import` when the compiler introduces a module."
        valueType: "boolean"
      }
      flippedImports: {
        description: "Allow imports via `import 'path': [specifier]` syntax."
        valueType: "boolean"
      }
      disableJsx: {
        description: "Don't parse JSX expressions."
        valueType: "boolean"
      }
      disableFlow: {
        description: "Don't parse Flow type annotations."
        valueType: "boolean"
      }
    }
  }

export getParserOpts(pluginOpts, initialParserOpts) ->
  parserOpts = initialParserOpts or {}
  parserOpts.parser = parser.parse

  parserOpts.plugins = parserOpts.plugins or []
  plugins = parserOpts.plugins

  plugins.unshift("lightscript")
  plugins.push("objectRestSpread")

  if not pluginOpts?.disableJsx: plugins.push("jsx")
  if not pluginOpts?.disableFlow: plugins.push("flow")
  if pluginOpts?.safeCall: plugins.push("safeCallExpression")
  if pluginOpts?.existential: plugins.push("existentialExpression")
  if pluginOpts?.bangCall: plugins.push("bangCall")
  if not pluginOpts?.noEnforcedSubscriptIndentation: plugins.push("enforceSubscriptIndentation")
  if pluginOpts?.flippedImports: plugins.push("flippedImports")

  patternMatchingVersion = pluginOpts?.patternMatching or "v4"
  if patternMatchingVersion != "disabled":
    plugins.push(`match_${patternMatchingVersion}`)

  parserOpts

// Attempt to determine whether a post-processed Babel plugin is this
// plugin. This is necessary because Babel doesn't specify the individual
// plugin configuration during manipulateOptions, only the global configuration.
// But we need the local plugin config there to enable parser flags.
// EXTREMELY hackish.
isMe(entry, thisPlugin) ->
  entry.manipulateOptions == thisPlugin.manipulateOptions

export locatePluginOpts(opts, thisPlugin) ->
  plugins = opts?.plugins
  if not plugins: return {}

  for elem plugin in plugins:
    if Array.isArray(plugin):
      if isMe(plugin[0], thisPlugin): return plugin[1]
    else:
      if isMe(plugin, thisPlugin): return {}

  {}
