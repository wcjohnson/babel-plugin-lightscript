import * as parser from "@oigroup/babylon-lightscript";
import packageMetadata from "../package.json";

// TODO: generalize this
export getMetadata() ->
  {
    parser
    getParserOpts
    name: packageMetadata.name
    version: packageMetadata.version
    fqn: packageMetadata.name + "@" + packageMetadata.version
    features: {
      "bangCall": {}
    }
  }

export getParserOpts(pluginOpts, initialParserOpts) ->
  parserOpts = initialParserOpts or {}
  parserOpts.parser = parser.parse

  parserOpts.plugins = parserOpts.plugins or []
  plugins = parserOpts.plugins

  plugins.unshift("lightscript")
  // TODO: allow configuration options to disable these, as they slow down parsing
  plugins.push("jsx", "flow", "objectRestSpread")
  plugins.push("safeCallExpression", "existentialExpression")

  if pluginOpts?.features?.bangCall: plugins.push("bangCall")

  parserOpts

// Attempt to determine whether a post-processed Babel plugin is this
// plugin. This is necessary because Babel doesn't specify the individual
// plugin configuration during manipulateOptions, only the global configuration.
// But we need the local plugin config there to enable parser flags.
// EXTREMELY hackish.
isMe(entry, thisPlugin) ->
  entry.manipulateOptions == thisPlugin.manipulateOptions

export locatePluginOpts(opts, thisPlugin) ->
  plugins = opts?.plugins
  if not plugins: return {}

  for elem plugin in plugins:
    if Array.isArray(plugin):
      if isMe(plugin[0], thisPlugin): return plugin[1]
    else:
      if isMe(plugin, thisPlugin): return {}

  {}
