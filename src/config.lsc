import * as parser from "@oigroup/babylon-lightscript";
import packageMetadata from "../package.json";

export getMetadata() ->
  {
    parser
    getParserOpts
    parseConfigurationDirectives
    name: packageMetadata.name
    version: packageMetadata.version
    options: {
      stdlib: {
        description: "Configure the LightScript standard library"
      }
      patternMatching: {
        description: "Test and branch using `match` keyword"
        valueType: "option"
        options: ["default", "enhanced"]
        defaultValue: "default"
        stage: "1"
      }
      whiteblock: {
        description: "Disable `{` `}` as block delimiters."
        valueType: "boolean"
      }
      bangCall: {
        description: "Call functions with paren-free syntax using `!`"
        valueType: "boolean"
        defaultValue: true
      }
      safeCall: {
        description: "Call a function using `?` to check callability first"
        valueType: "boolean"
        defaultValue: true
      }
      existential: {
        description: "Postfix `?` checks that an expression is not loose-equal to `null`"
        valueType: "boolean"
      }
      enhancedComprehension: {
        description: "Positional comprehensions and `case` syntax for comprehensions"
        valueType: "boolean"
        stage: "0"
      }
      noEnforcedSubscriptIndentation: {
        description: "Do not enforce indentation for subscripts on subsequent lines."
        valueType: "boolean"
      }
      useRequire: {
        description: "Generate `require` rather than `import` when the compiler introduces a module."
        valueType: "boolean"
      }
      flippedImports: {
        description: "Allow imports via `import 'path': [specifier]` syntax."
        valueType: "boolean"
      }
      disableJsx: {
        description: "Don't parse JSX expressions."
        valueType: "boolean"
      }
      disableFlow: {
        description: "Don't parse Flow type annotations."
        valueType: "boolean"
      }
      placeholderArgs: {
        description: "Specify arguments for a function using placeholders in the body."
        valueType: "boolean"
      }
      placeholder: {
        description: "Specify an identifier to be transformed into PlaceholderExpression."
        valueType: "string"
      }
      pipeCall: {
        description: "a |> b infix binary operator invokes b(a)"
        valueType: "boolean"
      }
    }
  }

export getParserOpts(pluginOpts, initialParserOpts) ->
  parserOpts = initialParserOpts or {}
  parserOpts.parser = parser.parse

  parserOpts.plugins = parserOpts.plugins or []
  plugins = parserOpts.plugins

  plugins.unshift("lightscript")
  plugins.push("objectRestSpread", "asyncFunctions", "asyncGenerators", "classProperties", "classConstructorCall", "decorators", "dynamicImport", "doExpressions", "seqExprRequiresParen")

  if pluginOpts?.whiteblock:
    if pluginOpts.whiteblock != "compat":
      plugins.push("whiteblockOnly")
  else:
    plugins.push("whiteblockPreferred")

  if not pluginOpts?.disableJsx: plugins.push("jsx")
  if not pluginOpts?.disableFlow: plugins.push("flow")
  if pluginOpts?.safeCall: plugins.push("safeCallExpression")
  if pluginOpts?.existential: plugins.push("existentialExpression")
  if pluginOpts?.bangCall != false: plugins.push("bangCall")
  if not pluginOpts?.noEnforcedSubscriptIndentation: plugins.push("enforceSubscriptIndentation")
  if pluginOpts?.flippedImports: plugins.push("flippedImports")
  if pluginOpts?.enhancedComprehension: plugins.push("splatComprehension")
  if pluginOpts?.placeholderArgs: plugins.push("syntacticPlaceholder")
  if pluginOpts?.placeholder:
    parserOpts.placeholder = pluginOpts.placeholder
  if pluginOpts?.pipeCall: plugins.push("pipeCall")

  // TODO: watch upstream on pattern matching; default to their syntax when complete
  // patternMatchingVersion = pluginOpts?.patternMatching or "v4"
  // if patternMatchingVersion != "disabled":
  //   plugins.push(`match_${patternMatchingVersion}`)
  plugins.push("match")

  parserOpts

// Attempt to determine whether a post-processed Babel plugin is this
// plugin. This is necessary because Babel doesn't specify the individual
// plugin configuration during manipulateOptions, only the global configuration.
// But we need the local plugin config there to enable parser flags.
// EXTREMELY hackish.
isMe(entry, thisPlugin) ->
  entry.manipulateOptions == thisPlugin.manipulateOptions

export locatePluginOpts(opts, thisPlugin) ->
  plugins = opts?.plugins
  if not plugins: return {}

  for elem plugin in plugins:
    if Array.isArray(plugin):
      if isMe(plugin[0], thisPlugin): return plugin[1]
    else:
      if isMe(plugin, thisPlugin): return {}

  {}

eatFluff(code) ->
  now code = code.trim()
  matches = code.match(/^(?:\/\/[^\r\n]*\r?\n?\s*)+([^]*)$/)
  if matches: matches[1] else:
    lcMatches = code.match(/^(?:\/\*[^]*?\*\/\s*)+([^]*)$/)
    if lcMatches: lcMatches[1] else: code

eatDirective(code, directives) ->
  now code = code.trim()
  matches = code.match(/^'((?:[^'\\]|\\.)*)'\s*;?\s*([^]*)$/)
  if matches:
    directives.push(matches[1])
    matches[2]
  else:
    dqMatches = code.match(/^"((?:[^"\\]|\\.)*)"\s*;?\s*([^]*)$/)
    if dqMatches:
      directives.push(dqMatches[1])
      dqMatches[2]
    else:
      code

// XXX: This is somewhat hackish. We can probably get Babylon to just parse the
// directives off the Program block as a plugin or something.
getDirectives(code) ->
  directives = []
  let before = code, after
  // eslint-disable-next-line no-constant-condition
  while true:
    now after = eatDirective(eatFluff(before), directives)
    if after == before: break
    now before = after
  directives

getClauseOptions(opts, clause) ->
  now clause = clause.split(':')
  if clause.length == 2:
    opt = clause[0].trim()
    val = clause[1].trim()
    if opt.length and val.length:
      try:
        opts[opt] = JSON.parse(val)
      catch err:
        return
  elif clause.length == 1:
    opt = clause[0].trim()
    if opt.length: opts[opt] = true

getWithOptions(opts, wc) ->
  clauses = wc.split(',')
  for elem clause in clauses:
    getClauseOptions(opts, clause)

export parseConfigurationDirectives(code) ->
  result = {}
  directives = getDirectives(code)
  for elem directive in directives:
    matches = directive.match(/^use \@oigroup\/lightscript\s*(?:with ([^]*))?$/)
    if matches:
      result.isLightScript = true
      if matches[1]: getWithOptions(result, matches[1])

  result
