import t from './lightscriptTypes'
import { toBlockStatement } from './blocks'
import { isa } from './is'
import { isDestructuringPattern, matchesDestructuringPattern } from './destructure'
import { createAndExpression as And } from './logical'
import { insertDeclarationBefore } from './variables'

import getLoc from 'ast-loc-utils/lib/getLoc'
import atLoc from 'ast-loc-utils/lib/placeAtLoc'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import getSurroundingLoc from 'ast-loc-utils/lib/getSurroundingLoc'
import span from 'ast-loc-utils/lib/span'

isUndefined(node) ->
  node.type == "Identifier" and node.name == "undefined"

isSignedNumber(node) ->
  node.type == "UnaryExpression" and
  (node.operator == "+" or node.operator == "-") and
  node.argument.type == "NumericLiteral"

createMatchTestReplacement(path, discriminantRef) ->
  node = path.node
  match node:
    | ~isa("LogicalExpression"):
      node.left = createMatchTestReplacement(path.get("left"), discriminantRef)
      node.right = createMatchTestReplacement(path.get("right"), discriminantRef)
      node
    | ~isa("UnaryExpression") and .operator == "!":
      node.argument = createMatchTestReplacement(path.get("argument"), discriminantRef)
      node
    | ~isa("RegExpLiteral"):
      loc = getLoc(node)
      t.callExpression(
        t.memberExpression(
          node, t.identifier("test")~atLoc(loc)
        )~atLoc(loc)
        [discriminantRef]
      )~atLoc(loc)
    | ~isUndefined() or ~isa("Literal") or ~isSignedNumber():
      t.binaryExpression("===", discriminantRef, node)~atNode(node)
    | ~isa("ObjectExpression") or ~isa("ArrayExpression"):
      throw path.buildCodeFrameError(
        "Object and array literals are illegal in test expressions. " +
        "To match against a destructuring pattern, " +
        "use `with` (eg: `| with { foo, bar }: foo + bar`)."
      )
    | else:
      node

transformPreTest({ discriminantRef }, testPath) ->
  createMatchTestReplacement(testPath, discriminantRef)

transformMatchTest(mtch, casePath) ->
  { test, binding } = casePath.node
  testPath = casePath.get("test")
  conditions = []
  { discriminantRef } = mtch

  if test: conditions.push(mtch~transformPreTest(testPath))
  if binding and binding~isDestructuringPattern():
    conditions.push(discriminantRef~matchesDestructuringPattern(binding))

  And(conditions)

transformBoundConsequent({discriminantRef}, binding, consequent) ->
  block = toBlockStatement(consequent)
  block.body.unshift(
    t.variableDeclaration("const", [
      t.variableDeclarator(binding, discriminantRef)~atNode(binding)
    ])~atNode(binding)
  )
  block

transformMatchConsequent(mtch, casePath) ->
  { binding, consequent } = casePath.node
  if binding:
    mtch~transformBoundConsequent(binding, consequent)
  else:
    consequent~toBlockStatement()

transformMatchCase(mtch, casePath) ->
  c = casePath.node
  {
    test: if c.test?.type != "MatchElse": mtch~transformMatchTest(casePath)
    consequent: mtch~transformMatchConsequent(casePath)
  }

transformMatchCases(mtch, casePaths) ->
  [casePath, ...rest] = casePaths
  c = casePath.node
  { test, consequent } = mtch~transformMatchCase(casePath)

  if rest.length > 0:
    loc = getSurroundingLoc([c, mtch.lastCase])
    t.ifStatement(test, consequent, mtch~transformMatchCases(rest))~atLoc(loc)
  elif test:
    t.ifStatement(test, consequent)~atNode(c)
  else:
    consequent

// Computed values needed in recursive descent.
getMatchInfo(path, discriminantRef) ->
  { node } = path
  { path, node, discriminantRef, lastCase: node.cases[node.cases.length - 1] }

export transformMatchExpression(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  matchBody = getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))

  iife = t.callExpression(
    t.arrowFunctionExpression(
      [alias], t.blockStatement([matchBody])~atNode(node)
    )~atNode(node)
    [discriminant]
  )~atNode(node)

  path.replaceWith(iife)

export transformMatchStatement(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  needsBlock = path.scope.hasBinding(alias.name)

  if needsBlock:
    path.replaceWith(
      t.blockStatement([
        t.variableDeclaration("const", [
          t.variableDeclarator(alias, discriminant)~atNode(discriminant)
        ])~atNode(discriminant)
        getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))
      ])~atNode(node)
    )
  else:
    path~insertDeclarationBefore(alias, discriminant, "const", discriminant~getLoc())
    path.replaceWith(
      getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))
    )
