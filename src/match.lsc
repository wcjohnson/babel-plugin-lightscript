import t from './lightscriptTypes'
import { toBlockStatement, toStatement } from './blocks'
import { isa } from './is'
import { undeclaredRef, isSimple } from './ref'
import { isDestructuringPattern, matchesDestructuringPattern } from './destructure'
import { createAndExpression as And } from './logical'
import { containsReferencedIdentifier } from './variables'

import getLoc from 'ast-loc-utils/lib/getLoc'
import atLoc from 'ast-loc-utils/lib/placeAtLoc'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import getSurroundingLoc from 'ast-loc-utils/lib/getSurroundingLoc'
import span from 'ast-loc-utils/lib/span'

isUndefined(node) ->
  node.type == "Identifier" and node.name == "undefined"

isSignedNumber(node) ->
  node.type == "UnaryExpression" and
  (node.operator == "+" or node.operator == "-") and
  node.argument.type == "NumericLiteral"

createMatchTestReplacement(node, discriminantRef) ->
  match node:
    | ~isa("LogicalExpression"):
      node.left = createMatchTestReplacement(node.left, discriminantRef)
      node.right = createMatchTestReplacement(node.right, discriminantRef)
      node
    | ~isa("UnaryExpression") and .operator == "!":
      node.argument = createMatchTestReplacement(node.argument, discriminantRef)
      node
    | ~isa("RegExpLiteral"):
      loc = getLoc(node)
      t.callExpression(
        t.memberExpression(
          node, t.identifier("test")~atLoc(loc)
        )~atLoc(loc)
        [discriminantRef]
      )~atLoc(loc)
    | ~isUndefined() or ~isa("Literal") or ~isSignedNumber():
      t.binaryExpression("===", discriminantRef, node)~atNode(node)
    | else:
      node

transformPreTest({ discriminantRef }, test) ->
  createMatchTestReplacement(test, discriminantRef)

transformMatchTest(mtch, { test, binding }) ->
  conditions = []
  { discriminantRef } = mtch

  if test: conditions.push(mtch~transformPreTest(test))
  if binding and binding~isDestructuringPattern():
    conditions.push(discriminantRef~matchesDestructuringPattern(binding))

  And(conditions)

transformBoundConsequent(mtch, binding, consequent) ->
  block = toBlockStatement(consequent)
  block.body.unshift(
    t.variableDeclaration("const", [
      t.variableDeclarator(binding, mtch.discriminantRef)~atNode(binding)
    ])~atNode(binding)
  )
  block

transformMatchConsequent(mtch, c) ->
  { binding, consequent } = c
  if binding:
    mtch~transformBoundConsequent(binding, consequent)
  else:
    consequent~toStatement()

transformMatchCase(mtch, c) ->
  {
    test: if c.test?.type != "MatchElse": mtch~transformMatchTest(c)
    consequent: mtch~transformMatchConsequent(c)
  }

transformMatchCases(mtch, [{node: c}, ...rest]) ->
  { test, consequent } = mtch~transformMatchCase(c)

  if rest.length > 0:
    loc = getSurroundingLoc([c, mtch.lastCase])
    t.ifStatement(test, consequent, mtch~transformMatchCases(rest))~atLoc(loc)
  elif test:
    t.ifStatement(test, consequent)~atNode(c)
  else:
    consequent

// Computed values needed in recursive descent.
getMatchInfo(path, discriminantRef) ->
  { node } = path
  { path, node, discriminantRef, lastCase: node.cases[node.cases.length - 1] }

export transformMatchExpression(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  matchBody = getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))

  // Wrap in IIFE
  iife = t.callExpression(
    t.arrowFunctionExpression(
      [alias], t.blockStatement([matchBody])~atNode(node)
    )~atNode(node)
    [discriminant]
  )~atNode(node)

  path.replaceWith(iife)

scopedReplace(path, replaced, replacement) ->
  targetScope = path.scope
  targetName = replaced.name

  path.traverse({
    Identifier(idPath): void ->
      if idPath.scope == targetScope and idPath.node.name == targetName:
        idPath.replaceWith(replacement)

    MatchStatement(path): void -> path.skip()
  })

export transformMatchStatement(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  if discriminant~isa("Identifier"):
    path~scopedReplace(alias, discriminant)
    path.replaceWith(
      getMatchInfo(path, discriminant)~transformMatchCases(path.get("cases"))
    )
  else:
    path.replaceWith(
      t.blockStatement([
        t.variableDeclaration("const", [
          t.variableDeclarator(alias, discriminant)~atNode(discriminant)
        ])~atNode(discriminant)
        getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))
      ])~atNode(node)
    )
