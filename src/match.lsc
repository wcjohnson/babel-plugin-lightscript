import t from './types'
import { toBlockStatement } from './blocks'
import { isa } from './is'
import { isDestructuringPattern, matchesDestructuringPattern } from './destructure'
import { createAndExpression as And } from './logical'
import { insertDeclarationBefore, containsReferencedIdentifier } from './variables'

import getLoc from 'ast-loc-utils/lib/getLoc'
import atLoc from 'ast-loc-utils/lib/placeAtLoc'
import atNode from 'ast-loc-utils/lib/placeAtNode'
import getSurroundingLoc from 'ast-loc-utils/lib/getSurroundingLoc'
import span from 'ast-loc-utils/lib/span'

isUndefined(node) ->
  node.type == "Identifier" and node.name == "undefined"

isSignedNumber(node) ->
  node.type == "UnaryExpression" and
  (node.operator == "+" or node.operator == "-") and
  node.argument.type == "NumericLiteral"

looksLikeClassName(id) ->
  { name } = id
  if name[0].toUpperCase() == name[0]:
    if name.length == 1: true
    elif name.toUpperCase() == name: false
    else: true
  else: false

isSimpleMemberExpression(node) ->
  node~isa("MemberExpression") and
  (not node.computed) and
  (node.object~isa("Identifier") or node.object~isSimpleMemberExpression())

isClassMatchable(node) ->
  (node~isa("Identifier") and node~looksLikeClassName()) or
  (node~isSimpleMemberExpression() and node.property~looksLikeClassName())

hasTypeof(ref, typeName, loc) ->
  t.binaryExpression("==="
    t.unaryExpression("typeof", ref)~atLoc(loc)
    t.stringLiteral(typeName)~atLoc(loc)
  )~atLoc(loc)

createClassMatchCondition(node, discriminantRef) ->
  name = if node~isa("MemberExpression"): node.property.name else: node.name

  match name:
    | "Number": discriminantRef~hasTypeof("number", node~getLoc())
    | "String": discriminantRef~hasTypeof("string", node~getLoc())
    | "Boolean": discriminantRef~hasTypeof("boolean", node~getLoc())
    | "Array":
      t.callExpression(
        t.memberExpression(
          t.identifier("Array")~atNode(node)
          t.identifier("isArray")~atNode(node)
        )~atNode(node)
        [discriminantRef]
      )~atNode(node)
    | else:
      t.binaryExpression("instanceof", discriminantRef, node)~atNode(node)

createMatchTestReplacement(path, discriminantRef) ->
  node = path.node
  match node:
    | ~isa("LogicalExpression"):
      node.left = createMatchTestReplacement(path.get("left"), discriminantRef)
      node.right = createMatchTestReplacement(path.get("right"), discriminantRef)
      node
    | ~isa("UnaryExpression") and .operator == "!":
      node.argument = createMatchTestReplacement(path.get("argument"), discriminantRef)
      node
    | ~isa("RegExpLiteral"):
      loc = getLoc(node)
      t.callExpression(
        t.memberExpression(
          node, t.identifier("test")~atLoc(loc)
        )~atLoc(loc)
        [discriminantRef]
      )~atLoc(loc)
    | ~isUndefined() or ~isa("Literal") or ~isSignedNumber():
      t.binaryExpression("===", discriminantRef, node)~atNode(node)
    | ~isa("ObjectExpression") or ~isa("ArrayExpression"):
      throw path.buildCodeFrameError(
        "Object and array literals are illegal in test expressions. " +
        "To match against a destructuring pattern, " +
        "use `with` (eg: `| with { foo, bar }: foo + bar`)."
      )
    | ~isClassMatchable():
      node~createClassMatchCondition(discriminantRef)
    | else:
      node

transformPreTest({ discriminantRef }, testPath) ->
  createMatchTestReplacement(testPath, discriminantRef)

transformMatchTest(mtch, casePath) ->
  { test, binding } = casePath.node
  testPath = casePath.get("test")
  conditions = []
  { discriminantRef } = mtch

  if test: conditions.push(mtch~transformPreTest(testPath))
  if binding and binding~isDestructuringPattern():
    conditions.push(discriminantRef~matchesDestructuringPattern(binding))

  And(conditions)

transformBoundConsequent({discriminantRef}, binding, consequent) ->
  block = toBlockStatement(consequent)
  block.body.unshift(
    t.variableDeclaration("const", [
      t.variableDeclarator(binding, discriminantRef)~atNode(binding)
    ])~atNode(binding)
  )
  block

transformMatchConsequent(mtch, casePath) ->
  { binding, consequent } = casePath.node
  if binding:
    mtch~transformBoundConsequent(binding, consequent)
  else:
    consequent~toBlockStatement()

transformMatchCase(mtch, casePath) ->
  c = casePath.node
  {
    test: if c.test?.type != "MatchElse": mtch~transformMatchTest(casePath)
    consequent: mtch~transformMatchConsequent(casePath)
  }

transformMatchCases(mtch, casePaths) ->
  [casePath, ...rest] = casePaths
  c = casePath.node
  { test, consequent } = mtch~transformMatchCase(casePath)

  if rest.length > 0:
    loc = getSurroundingLoc([c, mtch.lastCase])
    t.ifStatement(test, consequent, mtch~transformMatchCases(rest))~atLoc(loc)
  elif test:
    t.ifStatement(test, consequent)~atNode(c)
  else:
    consequent

// Computed values needed in recursive descent.
getMatchInfo(path, discriminantRef) ->
  { node } = path
  { path, node, discriminantRef, lastCase: node.cases[node.cases.length - 1] }

export transformMatchExpression(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  matchBody = getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))

  iife = t.callExpression(
    t.arrowFunctionExpression(
      [alias], t.blockStatement([matchBody])~atNode(node)
    )~atNode(node)
    [discriminant]
  )~atNode(node)

  path.replaceWith(iife)

export transformMatchStatement(path) ->
  node = path.node
  { discriminant, alias = t.identifier("it")~atLoc(node~getLoc()~span(1)) } = node

  elideAlias = discriminant~isa("Identifier") and (not path~containsReferencedIdentifier(alias))
  needsBlock = (not elideAlias) and path.scope.hasBinding(alias.name)

  if elideAlias:
    path.replaceWith(
      getMatchInfo(path, discriminant)~transformMatchCases(path.get("cases"))
    )
  elif needsBlock:
    path.replaceWith(
      t.blockStatement([
        t.variableDeclaration("const", [
          t.variableDeclarator(alias, discriminant)~atNode(discriminant)
        ])~atNode(discriminant)
        getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))
      ])~atNode(node)
    )
  else:
    path~insertDeclarationBefore(alias, discriminant, "const", discriminant~getLoc())
    path.replaceWith(
      getMatchInfo(path, alias)~transformMatchCases(path.get("cases"))
    )
