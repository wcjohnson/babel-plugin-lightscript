registerPlaceholder(functions, path, programPath) ->
  fnPath = path.getFunctionParent()
  if fnPath == programPath || !fnPath.node || !fnPath.node.params:
    throw path.buildCodeFrameError("Placeholders cannot be used outside functions.")

  if fnPath.node.params.length:
    throw path.buildCodeFrameError("Placeholders cannot be used in functions with arguments.")

  let fnInfo = functions.get(fnPath)
  if fnInfo:
    fnInfo.placeholders.push(path)
  else:
    functions.set(fnPath, { functionPath: fnPath, placeholders: [ path ] })

liftPlaceholders(fnPath, phPaths) ->
  // Collate placeholders
  ixPhPaths = phPaths.filter(x -> x.node.index?)
  nixPhPaths = phPaths.filter(x-> not x.node.index?)
  ixPhPaths.sort((a, b) -> a.node.index - b.node.index)
  sortedPhPaths = ixPhPaths.concat(nixPhPaths)

  // Formulate args
  args = []
  let prevIndex = undefined
  for elem phPath in sortedPhPaths:
    { node } = phPath
    if node.index? and node.index == prevIndex:
      phPath.replaceWith(args[args.length - 1])
    else:
      args.push(fnPath.scope.generateUidIdentifier("arg"))
      now prevIndex = node.index
      phPath.replaceWith(args[args.length - 1])

  // Lift args to function level
  fnNode = fnPath.node
  fnNode.params = args
  fnPath.replaceWith(fnNode)

// Collect all functions with placeholders into a Map, one entry per function
findFunctionsWithPlaceholders(programPath) ->
  fns = new Map()
  programPath.traverse({
    PlaceholderExpression(path): void ->
      registerPlaceholder(fns, path, programPath)
  })
  fns

export transformPlaceholders(programPath) ->
  fns = programPath~findFunctionsWithPlaceholders()
  fns.forEach( fnInfo ->
    fnInfo.functionPath~liftPlaceholders(fnInfo.placeholders)
  )
