// Tools for dealing with destructuring patterns.

import t from './types'
import { createAndExpression as And, createOrExpression as Or, createNotExpression as Not } from './logical'
import { runtime } from './runtime'
import { isa } from './is'
import atNode from 'ast-loc-utils/lib/placeAtNode'

export isDestructuringPattern(node) ->
  node.type == "ArrayPattern" or node.type == "ObjectPattern"

export matchesDestructuringPattern(ref, pattern) ->
  match pattern.type:
    | "ArrayPattern": ref~matchesArrayPattern(pattern)
    | "ObjectPattern": ref~matchesObjectPattern(pattern)

////////// Array pattern matching
Bracket(array, i, element) ->
  t.memberExpression(
    array
    t.numericLiteral(i)~atNode(element)
    true
  )~atNode(element)

HasLength(array, min, max, patternNode) ->
  args = if max:
    [ array, t.numericLiteral(min)~atNode(patternNode), t.numericLiteral(max)~atNode(patternNode) ]
  elif min > 0:
    [ array, t.numericLiteral(min)~atNode(patternNode) ]
  else:
    [ array ]

  t.callExpression(
    runtime('hasLength')~t.clone()~atNode(patternNode)
    args
  )

export matchesArrayPattern(array, arrayPattern) ->
  elements = arrayPattern.elements

  let minLength = 0
  conditions = [for idx i, elem element in elements:
    elementType = element?.type

    // Check for mandatory elements
    if elementType != "RestElement" and elementType != "AssignmentPattern":
      now minLength = i + 1

    if element and isDestructuringPattern(element):
      array~Bracket(i, element)~matchesDestructuringPattern(element)
  ]

  maxLength = if not (elements.length > 0 and elements[elements.length - 1].type == "RestElement"): elements.length

  // Length conditionals
  conditions.unshift(array~HasLength(minLength, maxLength, arrayPattern))

  And(conditions)

////////// Object pattern matching
In(key, obj) ->
  t.binaryExpression(
    'in'
    t.stringLiteral(key.name)~atNode(key)
    obj
  )~atNode(key)

Dot(obj, key) ->
  t.memberExpression(obj, key)~atNode(key)

HasProps(obj, patternNode, props) ->
  args = props.slice()
  args.unshift(obj)
  t.callExpression(
    runtime('hasProps')~t.clone()~atNode(patternNode)
    args
  )~atNode(patternNode)

export matchesObjectPattern(obj, objectPattern) ->
  { properties } = objectPattern

  // _hasProps(_obj, ...)
  conditions = [obj~HasProps(objectPattern, [
    for elem property in properties:
      if property~isa("ObjectProperty"):
        { key, value } = property
        if (not value~isa("AssignmentPattern") and key~isa("Identifier")):
          t.stringLiteral(key.name)~atNode(key)
  ])]

  // Conditions for nested patterns
  nestedConditions = [for elem property in properties:
    if property~isa("ObjectProperty"):
      { key, value } = property
      match value:
        | .type == "AssignmentPattern" and isDestructuringPattern(.left):
          Or(
            Not(key~In(obj))
            obj~Dot(key)~matchesDestructuringPattern(value.left)
          )
        | ~isDestructuringPattern():
          obj~Dot(key)~matchesDestructuringPattern(value)
  ]

  And(conditions.concat(nestedConditions))

////////// "Restructuring" after a destructure
export toRestructureExpression(pattern) ->
  match pattern.type:
    | "ArrayPattern": pattern~toRestructureExpressionForArrayPattern()
    | "ObjectPattern": pattern~toRestructureExpressionForObjectPattern()

maybeToRestructureExpression(node) ->
  if node~isDestructuringPattern(): node~toRestructureExpression() else: node

export toRestructureExpressionForArrayPattern(pattern) ->
  t.arrayExpression(
    [for elem element in pattern.elements:
      match element:
        | ~isa("AssignmentPattern"): element.left~maybeToRestructureExpression()
        | ~isa("RestElement"): t.spreadElement(element.argument)~atNode(element)
        | else: element~maybeToRestructureExpression()
    ]
  )~atNode(pattern)

restructureObjAssignment(assign, defaultKey) ->
  if assign.left~isDestructuringPattern():
    t.objectProperty(defaultKey, assign.left~toRestructureExpression())
  else:
    t.objectProperty(assign.left, assign.left, false, true)

export toRestructureExpressionForObjectPattern(pattern) ->
  t.objectExpression(
    [for elem property in pattern.properties:
      match property:
        | ~isa("RestProperty"):
          t.spreadProperty(property.argument)~atNode(property)
        | .value~isDestructuringPattern():
          t.objectProperty(
            property.key
            property.value~toRestructureExpression()
          )~atNode(property)
        | .value~isa("AssignmentPattern"):
          property.value~restructureObjAssignment(property.key)~atNode(property)
        | .value~isa("Identifier"):
          t.objectProperty(property.value, property.value, false, true)~atNode(property)
    ]
  )~atNode(pattern)

////////// Generate accessor expressions for destructuring patterns
export accessors(node, nodeAccessor, accum) ->
  match node:
    | ~isa("Identifier"): accum[node.name] = nodeAccessor
    | ~isa("ArrayPattern"): node~accessorsForArrayPattern(nodeAccessor, accum)
    | ~isa("ObjectPattern"): node~accessorsForObjectPattern(nodeAccessor, accum)
    | ~isa("AssignmentPattern"): node.left~accessors(nodeAccessor, accum)

accessorsForArrayPattern(pattern, accessor, accum) ->
  for idx i, elem element in pattern.elements:
    element~accessors(t.memberExpression(accessor, t.numericLiteral(i), true), accum)

accessorsForObjectPattern(pattern, accessor, accum) ->
  for elem { key, value } in pattern.properties:
    if key~isa("Identifier"):
      value~accessors(t.memberExpression(accessor, key), accum)
