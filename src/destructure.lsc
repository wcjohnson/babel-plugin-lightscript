// Generate a LogicalExpression that asserts a ref is compatible with a
// destructuring pattern.

import t from './lightscriptTypes'
import { createAndExpression as And, createOrExpression as Or, createNotExpression as Not } from './logical'
import { helper } from './helpers'
import { isa } from './is'
import atNode from 'ast-loc-utils/lib/placeAtNode'

export isDestructuringPattern(node) ->
  node.type == "ArrayPattern" or node.type == "ObjectPattern"

export matchesDestructuringPattern(ref, pattern) ->
  match pattern.type:
    | "ArrayPattern": ref~matchesArrayPattern(pattern)
    | "ObjectPattern": ref~matchesObjectPattern(pattern)

////////// Array pattern matching
Bracket(array, i, element) ->
  t.memberExpression(
    array
    t.numericLiteral(i)~atNode(element)
    true
  )~atNode(element)

HasLength(array, min, max, patternNode) ->
  args = if max:
    [ array, t.numericLiteral(min)~atNode(patternNode), t.numericLiteral(max)~atNode(patternNode) ]
  elif min > 0:
    [ array, t.numericLiteral(min)~atNode(patternNode) ]
  else:
    [ array ]

  t.callExpression(
    helper('hasLength')~t.clone()~atNode(patternNode)
    args
  )

export matchesArrayPattern(array, arrayPattern) ->
  elements = arrayPattern.elements

  let minLength = 0
  conditions = [for idx i, elem element in elements:
    elementType = element?.type

    // Check for mandatory elements
    if elementType != "RestElement" and elementType != "AssignmentPattern":
      now minLength = i + 1

    if element and isDestructuringPattern(element):
      array~Bracket(i, element)~matchesDestructuringPattern(element)
  ]

  maxLength = if not (elements.length > 0 and elements[elements.length - 1].type == "RestElement"): elements.length

  // Length conditionals
  conditions.unshift(array~HasLength(minLength, maxLength, arrayPattern))

  And(conditions)

////////// Object pattern matching
In(key, obj) ->
  t.binaryExpression(
    'in'
    t.stringLiteral(key.name)~atNode(key)
    obj
  )~atNode(key)

Dot(obj, key) ->
  t.memberExpression(obj, key)~atNode(key)

HasProps(obj, patternNode, props) ->
  args = props.slice()
  args.unshift(obj)
  t.callExpression(
    helper('hasProps')~t.clone()~atNode(patternNode)
    args
  )~atNode(patternNode)

export matchesObjectPattern(obj, objectPattern) ->
  { properties } = objectPattern

  // _hasProps(_obj, ...)
  conditions = [obj~HasProps(objectPattern, [
    for elem { key, value } in properties:
      if (not value~isa("AssignmentPattern") and key~isa("Identifier")):
        t.stringLiteral(key.name)~atNode(key)
  ])]

  // Conditions for nested patterns
  nestedConditions = [for elem { key, value } in properties:
    match value:
      | .type == "AssignmentPattern" and isDestructuringPattern(.left):
        Or(
          Not(key~In(obj))
          obj~Dot(key)~matchesDestructuringPattern(value.left)
        )
      | ~isDestructuringPattern():
        obj~Dot(key)~matchesDestructuringPattern(value)
  ]

  And(conditions.concat(nestedConditions))

////////// "Restructuring" after a destructure
export toRestructureExpression(pattern) ->
  match pattern.type:
    | "ArrayPattern": pattern~toRestructureExpressionForArrayPattern()
    | "ObjectPattern": pattern~toRestructureExpressionForObjectPattern()

maybeToRestructureExpression(node) ->
  if node~isDestructuringPattern(): node~toRestructureExpression() else: node

export toRestructureExpressionForArrayPattern(pattern) ->
  t.arrayExpression(
    [for elem element in pattern.elements:
      match element:
        | ~isa("AssignmentPattern"): element.left~maybeToRestructureExpression()
        | else: element~maybeToRestructureExpression()
    ]
  )~atNode(pattern)

restructureObjAssignment(assign, defaultKey) ->
  if assign.left~isDestructuringPattern():
    t.objectProperty(defaultKey, assign.left~toRestructureExpression())
  else:
    t.objectProperty(assign.left, assign.left, false, true)

export toRestructureExpressionForObjectPattern(pattern) ->
  t.objectExpression(
    [for elem property in pattern.properties:
      match property.value:
        | ~isDestructuringPattern():
          t.objectProperty(
            property.key
            property.value~toRestructureExpression()
          )~atNode(property)
        | ~isa("AssignmentPattern"):
          property.value~restructureObjAssignment(property.key)~atNode(property)
        | ~isa("Identifier"):
          t.objectProperty(property.value, property.value, false, true)~atNode(property)
    ]
  )~atNode(pattern)
