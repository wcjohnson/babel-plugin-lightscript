// Generate a LogicalExpression that asserts a ref is compatible with a
// destructuring pattern.

import t from './lightscriptTypes'
import { createAndExpression as And, createOrExpression as Or, createNotExpression as Not } from './logical'
import { helper } from './helpers'
import atNode from 'ast-loc-utils/lib/placeAtNode'

export isDestructuringPattern(node) ->
  node.type == "ArrayPattern" or node.type == "ObjectPattern"

export matchesDestructuringPattern(ref, pattern) ->
  match pattern.type:
    | "ArrayPattern": ref~matchesArrayPattern(pattern)
    | "ObjectPattern": ref~matchesObjectPattern(pattern)

////////// Array pattern matching
Bracket(array, i, element) ->
  t.memberExpression(
    array
    t.numericLiteral(i)~atNode(element)
    true
  )~atNode(element)

HasLength(array, min, max, patternNode) ->
  args = if max:
    [ array, t.numericLiteral(min)~atNode(patternNode), t.numericLiteral(max)~atNode(patternNode) ]
  elif min > 0:
    [ array, t.numericLiteral(min)~atNode(patternNode) ]
  else:
    [ array ]

  t.callExpression(
    helper('hasLength')~t.clone()~atNode(patternNode)
    args
  )

export matchesArrayPattern(array, arrayPattern) ->
  elements = arrayPattern.elements

  let minLength = 0
  conditions = [for idx i, elem element in elements:
    elementType = element?.type

    // Check for mandatory elements
    if elementType != "RestElement" and elementType != "AssignmentPattern":
      now minLength = i + 1

    if isDestructuringPattern(element):
      array~Bracket(i, element)~matchesDestructuringPattern(element)
  ]

  maxLength = if not (elements.length > 0 and elements[elements.length - 1].type == "RestElement"): elements.length

  // Length conditionals
  conditions.unshift(array~HasLength(minLength, maxLength, arrayPattern))

  And(conditions)

////////// Object pattern matching
In(key, obj) ->
  t.binaryExpression(
    'in'
    t.stringLiteral(key.name)~atNode(key)
    obj
  )~atNode(key)

Dot(obj, key) ->
  t.memberExpression(obj, key)~atNode(key)

IsObject(ref, patternNode) ->
  t.callExpression(
    helper('isObject')~t.clone()~atNode(patternNode)
    [ref]
  )~atNode(patternNode)

export matchesObjectPattern(obj, objectPattern) ->
  properties = objectPattern.properties

  conditions = [for elem property in properties:
    { key, value } = property

    match value:
      | .type == "AssignmentPattern" and isDestructuringPattern(.left):
        Or(
          Not(key~In(obj))
          obj~Dot(key)~matchesDestructuringPattern(value.left)
          // value.right~matchesDestructuringPattern(value.left)
        )
      | ~isDestructuringPattern():
        obj~Dot(key)~matchesDestructuringPattern(value)
      | .type != "AssignmentPattern":
        key~In(obj)
  ]

  conditions.unshift(obj~IsObject(objectPattern))

  And(conditions)
