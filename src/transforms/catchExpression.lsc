import t, { isa } from '../types'
import { transformTails } from '../helpers/tails'

import {
  getLoc, placeAtLoc as atLoc, placeAtNode as atNode,
  getSurroundingLoc, span, traverse,
  placeTreeAtLocWhenUnplaced as allAtLoc
} from 'ast-loc-utils'

import { getMatchInfo, transformMatchCases } from './match'

transformCatchExpressionStatement(path, catchExprPath, isLinter): void ->
  { node } = catchExprPath

  errRef = node.binding
  catchBody = if node.cases:
    getMatchInfo(catchExprPath, errRef, isLinter)~transformMatchCases(catchExprPath.get("cases"))
  else:
    node.body

  path.replaceWith! t.tryStatement(
    // try { expr }
    t.blockStatement([
      t.expressionStatement(node.expression)~atNode(node.expression)
    ])~atNode(node.expression)
    // catch (err) { ... }
    t.catchClause(
      errRef
      t.blockStatement([catchBody])
    )
  )

transformVarDeclCatchExpression(path, catchExprPath, isLinter): void ->
  { node } = catchExprPath

  resRef = path.scope.generateUidIdentifier("val")
  errRef = node.binding
  catchBody = if node.cases:
    getMatchInfo(catchExprPath, errRef, isLinter)~transformMatchCases(catchExprPath.get("cases"))
  else:
    node.body

  path.insertBefore! t.variableDeclaration("let", [t.variableDeclarator(resRef)])
  path.insertBefore! t.tryStatement(
    // try { _val = expr }
    t.blockStatement([
      t.expressionStatement(t.assignmentExpression("=", resRef, node.expression))
    ])
    // catch (err) { ... }
    t.catchClause(
      errRef
      t.blockStatement([catchBody])
    )
  )
  // x = _val
  declaratorPath = path.get("declarations.0")
  declaratorPath.node.init = resRef
  // Transform tails in the catch-clause to assignments
  tryPath = path.getPrevSibling()
  transformTails(tryPath.get("handler.body"), false, false, (node) ->
    t.assignmentExpression("=", resRef, node)~atNode(node)
  )

transformPessimizedCatchExpression(path, isLinter): void ->
  { node } = path

  errRef = node.binding
  catchBody = if node.cases:
    getMatchInfo(path, errRef, isLinter)~transformMatchCases(path.get("cases"))
  else:
    node.body

  iife = t.callExpression(
    t.arrowFunctionExpression(
      []
      t.blockStatement([
        t.tryStatement(
          t.blockStatement([
            t.returnStatement(node.expression)
          ])
          t.catchClause(
            errRef
            t.blockStatement([catchBody])
          )
        )
      ])
      node.expression~isa("AwaitExpression") // async
    )
    []
  )

  path.replaceWith(iife)

isVarDeclCatchExpr(path) ->
  path.parent~isa("VariableDeclarator")
  and path.parentPath.parent.declarations.length == 1
  and path.parentPath.parentPath.listKey == "body"

isCatchExprStatement(path) ->
  path.parent~isa("ExpressionStatement")

export transformCatchExpression(path, isLinter): void ->
  if path~isVarDeclCatchExpr!:
    transformVarDeclCatchExpression(path.parentPath.parentPath, path, isLinter)
  elif path~isCatchExprStatement!:
    transformCatchExpressionStatement(path.parentPath, path, isLinter)
  else:
    transformPessimizedCatchExpression(path, isLinter)

